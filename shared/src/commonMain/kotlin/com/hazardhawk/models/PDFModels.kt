package com.hazardhawk.models

/**
 * PDF export data structures for OSHA-compliant construction documentation
 * Supports multi-platform PDF generation with signatures and metadata
 */

/**
 * Request data for PDF document export
 * Contains all information needed to generate a compliant construction safety document
 */
data class PDFExportRequest(
    val documentId: String,
    val documentType: DocumentType,
    val includePhotos: Boolean = true,
    val includeSignature: Boolean = true,
    val metadata: PDFMetadata,
    val photoIds: List<String> = emptyList(),
    val signatureData: SignatureData? = null,
    val customTemplate: String? = null
) {
    /**
     * Validate that the request has all required data for the document type
     */
    fun validate(): Result<Unit> {
        return try {
            when (documentType) {
                DocumentType.INCIDENT_REPORT -> {
                    require(includePhotos && photoIds.isNotEmpty()) {
                        "Incident reports must include photos"
                    }
                }
                DocumentType.PTP -> {
                    require(includeSignature && signatureData != null) {
                        "Pre-Task Plans must include signature"
                    }
                }
                DocumentType.TOOLBOX_TALK -> {
                    require(includeSignature && signatureData != null) {
                        "Toolbox Talks must include signature"
                    }
                }
            }
            
            require(metadata.projectName.isNotBlank()) {
                "Project name is required"
            }
            require(metadata.generatedBy.isNotBlank()) {
                "Generated by information is required"
            }
            
            Result.success(Unit)
        } catch (e: IllegalArgumentException) {
            Result.failure(e)
        }
    }
    
    /**
     * Generate a default filename for this export request
     */
    fun generateFileName(): String {
        val timestamp = System.currentTimeMillis()
        val docType = documentType.name.lowercase().replace('_', '-')
        val projectName = metadata.projectName.replace("[^a-zA-Z0-9]".toRegex(), "-")
        return "${docType}-${projectName}-${timestamp}.pdf"
    }
}

/**
 * Metadata for PDF documents including OSHA compliance requirements
 * Contains all header/footer information for construction safety documents
 */
data class PDFMetadata(
    val projectName: String,
    val location: String,
    val generatedBy: String,
    val generatedDate: Long,
    val companyLogo: String? = null,
    val companyName: String? = null,
    val projectNumber: String? = null,
    val oshaCompliance: OSHAComplianceInfo? = null,
    val weatherConditions: String? = null,
    val temperatureF: Int? = null,
    val additionalNotes: String? = null
) {
    /**
     * Format the generation date for display in documents
     */
    fun getFormattedDate(): String {
        // This would use platform-specific date formatting
        // For now, return ISO format
        return java.util.Date(generatedDate).toString()
    }
    
    /**
     * Get company information for document header
     */
    fun getCompanyInfo(): String {
        return companyName ?: "HazardHawk Safety Management"
    }
}

/**
 * OSHA compliance information for safety documents
 */
data class OSHAComplianceInfo(
    val standardsApplied: List<String> = emptyList(),
    val trainingCompleted: Boolean = false,
    val equipmentInspected: Boolean = false,
    val emergencyProceduresReviewed: Boolean = false,
    val complianceOfficer: String? = null
)

/**
 * Digital signature data for document authentication
 * Supports both drawn signatures and typed acceptance
 */
data class SignatureData(
    val signaturePath: String, // Path to signature image file
    val signerName: String,
    val signerRole: String,
    val signedDate: Long,
    val signatureType: SignatureType = SignatureType.DRAWN,
    val ipAddress: String? = null,
    val deviceInfo: String? = null
) {
    /**
     * Validate signature data completeness
     */
    fun validate(): Result<Unit> {
        return try {
            require(signerName.isNotBlank()) { "Signer name is required" }
            require(signerRole.isNotBlank()) { "Signer role is required" }
            require(signaturePath.isNotBlank()) { "Signature path is required" }
            require(signedDate > 0) { "Signed date must be valid" }
            
            Result.success(Unit)
        } catch (e: IllegalArgumentException) {
            Result.failure(e)
        }
    }
    
    /**
     * Get formatted signature date for display
     */
    fun getFormattedSignedDate(): String {
        return java.util.Date(signedDate).toString()
    }
}

/**
 * Types of digital signatures supported
 */
enum class SignatureType {
    DRAWN,      // Hand-drawn signature on touchscreen
    TYPED,      // Typed acceptance with checkbox
    BIOMETRIC   // Future: fingerprint or other biometric
}

/**
 * State management for PDF export operations
 * Provides progress tracking and error handling
 */
sealed class PDFExportState {
    object Idle : PDFExportState()
    
    data class Loading(
        val progress: Float,
        val message: String,
        val currentStep: ExportStep = ExportStep.PREPARING
    ) : PDFExportState()
    
    data class Success(
        val filePath: String,
        val fileName: String,
        val fileSize: Long = 0L,
        val exportTime: Long = System.currentTimeMillis()
    ) : PDFExportState() {
        /**
         * Get human-readable file size
         */
        fun getFormattedFileSize(): String {
            return when {
                fileSize < 1024 -> "${fileSize}B"
                fileSize < 1024 * 1024 -> "${fileSize / 1024}KB"
                else -> "${fileSize / (1024 * 1024)}MB"
            }
        }
    }
    
    data class Error(
        val message: String,
        val exception: Throwable? = null,
        val errorCode: PDFExportErrorCode = PDFExportErrorCode.UNKNOWN,
        val retryable: Boolean = true
    ) : PDFExportState() {
        /**
         * Get user-friendly error message
         */
        fun getUserMessage(): String {
            return when (errorCode) {
                PDFExportErrorCode.PERMISSION_DENIED -> "Permission denied. Please check storage permissions."
                PDFExportErrorCode.INSUFFICIENT_SPACE -> "Not enough storage space available."
                PDFExportErrorCode.INVALID_DATA -> "Invalid document data. Please try again."
                PDFExportErrorCode.NETWORK_ERROR -> "Network error. Check your connection and try again."
                PDFExportErrorCode.SIGNATURE_REQUIRED -> "A signature is required for this document type."
                PDFExportErrorCode.PHOTOS_REQUIRED -> "Photos are required for this document type."
                PDFExportErrorCode.UNKNOWN -> message
            }
        }
    }
}

/**
 * Export process steps for progress tracking
 */
enum class ExportStep {
    PREPARING,
    VALIDATING_DATA,
    LOADING_TEMPLATE,
    PROCESSING_PHOTOS,
    ADDING_SIGNATURE,
    GENERATING_PDF,
    SAVING_FILE,
    COMPLETED
}

/**
 * Specific error codes for PDF export failures
 */
enum class PDFExportErrorCode {
    PERMISSION_DENIED,
    INSUFFICIENT_SPACE,
    INVALID_DATA,
    NETWORK_ERROR,
    SIGNATURE_REQUIRED,
    PHOTOS_REQUIRED,
    TEMPLATE_ERROR,
    UNKNOWN
}

/**
 * PDF template configuration for different document types
 */
data class PDFTemplate(
    val documentType: DocumentType,
    val templateName: String,
    val templateVersion: String,
    val headerHeight: Float = 72f, // Points
    val footerHeight: Float = 36f, // Points
    val margins: PDFMargins = PDFMargins(),
    val supportedFeatures: Set<PDFFeature> = emptySet()
) {
    companion object {
        /**
         * Get default template for document type
         */
        fun getDefault(documentType: DocumentType): PDFTemplate {
            return when (documentType) {
                DocumentType.PTP -> PDFTemplate(
                    documentType = documentType,
                    templateName = "OSHA Pre-Task Plan",
                    templateVersion = "v1.0",
                    supportedFeatures = setOf(PDFFeature.SIGNATURE, PDFFeature.PHOTOS, PDFFeature.METADATA)
                )
                DocumentType.TOOLBOX_TALK -> PDFTemplate(
                    documentType = documentType,
                    templateName = "Safety Toolbox Talk",
                    templateVersion = "v1.0",
                    supportedFeatures = setOf(PDFFeature.SIGNATURE, PDFFeature.METADATA)
                )
                DocumentType.INCIDENT_REPORT -> PDFTemplate(
                    documentType = documentType,
                    templateName = "Incident Report",
                    templateVersion = "v1.0",
                    supportedFeatures = setOf(PDFFeature.SIGNATURE, PDFFeature.PHOTOS, PDFFeature.METADATA, PDFFeature.LOCATION)
                )
            }
        }
    }
}

/**
 * PDF page margins in points
 */
data class PDFMargins(
    val top: Float = 36f,
    val bottom: Float = 36f,
    val left: Float = 36f,
    val right: Float = 36f
)

/**
 * Features supported by PDF templates
 */
enum class PDFFeature {
    SIGNATURE,
    PHOTOS,
    METADATA,
    LOCATION,
    QR_CODE,
    WATERMARK,
    ENCRYPTION
}